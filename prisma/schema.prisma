// Prisma Schema for Supetron
// AI-Powered Micro App Platform

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL") // Direct connection for migrations (bypasses pgbouncer)
}

// ============================================
// USER MANAGEMENT
// ============================================

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  passwordHash  String?   @map("password_hash") // Optional: OAuth users don't have passwords
  emailVerified DateTime? @map("email_verified") // For OAuth providers
  avatarUrl     String?   @map("avatar_url")
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  // OAuth accounts (Google, GitHub, etc.)
  accounts Account[]

  apps           App[]
  conversations  AppConversation[]
  userConnectors UserConnector[]
  appRuns        AppRun[]
  appData        AppData[]
  apiKeys        ApiKey[]

  @@map("users")
}

// NextAuth.js Account model for OAuth providers
model Account {
  id                String  @id @default(cuid())
  userId            String  @map("user_id")
  type              String
  provider          String
  providerAccountId String  @map("provider_account_id")
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
  @@map("accounts")
}

// ============================================
// AI-GENERATED APPS
// ============================================

model App {
  id             String    @id @default(cuid())
  name           String
  description    String?
  icon           String?
  currentVersion String    @default("1.0.0") @map("current_version") // Semantic versioning
  status         AppStatus @default(DRAFT)
  appConfig      Json      @map("app_config") // Universal AppConfig schema (UI config, no code)
  appCode        String?   @db.Text @map("app_code") // JavaScript code stored separately (avoids JSON escaping issues)
  originalPrompt String?   @map("original_prompt") // User's natural language prompt

  userId String @map("user_id")
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Conversation that created this app
  conversationId String?          @unique @map("conversation_id")
  conversation   AppConversation? @relation(fields: [conversationId], references: [id])

  // Version history
  versions AppVersion[]

  runs      AppRun[]
  data      AppData[]
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([userId])
  @@map("apps")
}

// ============================================
// CONNECTOR MARKETPLACE
// ============================================

// System-defined connector templates (Gmail, Notion, REST API, etc.)
model ConnectorTemplate {
  id          String        @id @default(cuid())
  name        String        @unique // e.g., "Gmail", "Notion", "REST API"
  icon        String?
  category    String // email, calendar, productivity, social, custom
  type        ConnectorType
  description String?

  // OAuth2 config (for OAuth connectors)
  authUrl  String? @map("auth_url")
  tokenUrl String? @map("token_url")
  scopes   String[] @default([])

  // REST config defaults
  baseUrl String? @map("base_url")

  userConnectors UserConnector[]

  isActive  Boolean  @default(true) @map("is_active")
  createdAt DateTime @default(now()) @map("created_at")

  @@map("connector_templates")
}

// User's connected instances of connectors
model UserConnector {
  id       String  @id @default(cuid())
  name     String // User's custom name for this connection
  isActive Boolean @default(true) @map("is_active")

  templateId String            @map("template_id")
  template   ConnectorTemplate @relation(fields: [templateId], references: [id])

  // Auth credentials (should be encrypted at application level)
  authType    AuthType  @map("auth_type")
  credentials Json? // Encrypted: tokens, apiKey, etc.

  // REST API specific overrides
  baseUrl String? @map("base_url")
  headers Json?

  userId String @map("user_id")
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([userId])
  @@index([templateId])
  @@map("user_connectors")
}

// ============================================
// GENERIC APP DATA STORAGE
// ============================================

// Flexible JSON storage for app-specific data (expenses, habits, notes, etc.)
model AppData {
  id    String @id @default(cuid())
  appId String @map("app_id")
  app   App    @relation(fields: [appId], references: [id], onDelete: Cascade)

  userId String @map("user_id")
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  dataType String? @map("data_type") // Optional: "expense", "habit", "note" for filtering
  data     Json // Flexible JSON storage for any app record

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([appId, userId])
  @@index([appId, dataType])
  @@map("app_data")
}

// ============================================
// APP EXECUTION HISTORY
// ============================================

model AppRun {
  id       String    @id @default(cuid())
  status   RunStatus @default(PENDING)
  inputs   Json?
  outputs  Json?
  error    String?
  duration Int? // milliseconds

  appId  String @map("app_id")
  app    App    @relation(fields: [appId], references: [id], onDelete: Cascade)
  userId String @map("user_id")
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now()) @map("created_at")

  @@index([appId])
  @@index([userId])
  @@map("app_runs")
}

// ============================================
// APP CONVERSATIONS (Chat History)
// ============================================

model AppConversation {
  id    String  @id @default(cuid())
  title String? // Auto-generated from first prompt

  userId String @map("user_id")
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  messages Message[]
  app      App? // One-to-one: conversation can produce one app

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([userId])
  @@map("app_conversations")
}

model Message {
  id             String          @id @default(cuid())
  conversationId String          @map("conversation_id")
  conversation   AppConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  role    MessageRole
  content String      @db.Text

  // Artifact: snapshot of app at this message
  hasArtifact    Boolean @default(false) @map("has_artifact")
  artifactName   String? @map("artifact_name") // App name at this point
  artifactIcon   String? @map("artifact_icon") // App icon at this point
  artifactConfig Json?   @map("artifact_config") // Full AppConfig snapshot
  artifactCode   String? @db.Text @map("artifact_code") // Code snapshot

  createdAt DateTime @default(now()) @map("created_at")

  @@index([conversationId])
  @@map("messages")
}

// ============================================
// APP VERSION HISTORY
// ============================================

model AppVersion {
  id    String @id @default(cuid())
  appId String @map("app_id")
  app   App    @relation(fields: [appId], references: [id], onDelete: Cascade)

  version   String // Semantic: "1.0.0", "1.1.0", "2.0.0"
  appConfig Json   @map("app_config")
  appCode   String? @db.Text @map("app_code")
  changelog String? // What changed in this version

  // Reference to the message that created this version
  messageId String? @map("message_id")

  createdAt DateTime @default(now()) @map("created_at")

  @@unique([appId, version])
  @@index([appId])
  @@map("app_versions")
}

// ============================================
// ENUMS
// ============================================

enum ConnectorType {
  OAUTH2   // Gmail, Notion, Google Calendar, etc.
  REST_API // Custom REST APIs

  @@map("connector_type")
}

enum AuthType {
  NONE
  API_KEY
  BASIC
  BEARER
  OAUTH2

  @@map("auth_type")
}

enum AppStatus {
  DRAFT
  ACTIVE
  ARCHIVED

  @@map("app_status")
}

enum RunStatus {
  PENDING
  RUNNING
  SUCCESS
  FAILED

  @@map("run_status")
}

enum MessageRole {
  USER
  ASSISTANT
  SYSTEM

  @@map("message_role")
}

enum LLMProvider {
  GOOGLE    // Google Gemini
  OPENAI    // OpenAI GPT
  ANTHROPIC // Anthropic Claude
  MISTRAL   // Mistral AI
  GROQ      // Groq (fast inference)
  DEEPSEEK  // DeepSeek

  @@map("llm_provider")
}

// ============================================
// USER API KEYS FOR LLM PROVIDERS
// ============================================

model ApiKey {
  id        String      @id @default(cuid())
  provider  LLMProvider
  apiKey    String      @map("api_key") // Encrypted at application level
  baseUrl   String?     @map("base_url") // Optional: for Azure, self-hosted, or proxy endpoints
  label     String? // User-friendly name like "My OpenAI Key"
  isActive  Boolean     @default(true) @map("is_active")
  isDefault Boolean     @default(false) @map("is_default")

  userId String @map("user_id")
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([userId, provider])
  @@index([userId])
  @@map("api_keys")
}
